use super::nodes;
use anyhow::anyhow;
use std::{collections::HashMap, marker::PhantomData, sync::Arc};
use type_sitter::Node;

use crate::{
    errors::DiagnosticEmitter,
    hir::{
        self,
        hir::{Hir, HirArena},
        HirKind,
    },
    source::{SourceManager, TextSource, Uri},
};

use super::ast::Ast;

/// Lower ast generated by type_sitter down to hir

pub struct LoweringContext<'ctx, Emitter: DiagnosticEmitter> {
    pub diag_emitter: Arc<Emitter>,
    pub sources: &'ctx SourceManager,
    pub current_origin: Option<Arc<Uri>>,
}

fn lower_err() -> anyhow::Error {
    anyhow!("Failed to lower AST to HIR")
}

impl<'ctx, E: DiagnosticEmitter> LoweringContext<'ctx, E> {
    fn source_text(&self) -> anyhow::Result<&String> {
        self.sources.get(self.current_origin.as_ref().unwrap())
    }

    fn node_source<'tree>(&self, node: impl Node<'tree>) -> TextSource {
        TextSource {
            source: self.current_origin.clone().unwrap(),
            span: node.byte_range(),
        }
    }

    fn node_text<'tree>(&self, node: impl type_sitter::Node<'tree>) -> anyhow::Result<&str> {
        let range = node.byte_range();
        Ok(&self.source_text()?[range.start..range.end])
    }

    fn expect_node<'tree, T>(
        &mut self,
        result: type_sitter::NodeResult<'tree, T>,
    ) -> anyhow::Result<T> {
        match result {
            Ok(node) => Ok(node),
            Err(err) => {
                println!("Was expecting node, but *error*");
                self.diag_emitter
                    .error(
                        format!(
                            "Was expecting {} but found \"{}\" with content: {}",
                            err.kind,
                            err.node.kind(),
                            self.node_text(err.node)?
                        ),
                        self.current_origin.as_ref().unwrap().to_string(),
                    )
                    .err_at(err.node.byte_range(), format!("expected {}", err.kind))
                    .emit(self.source_text()?);
                Err(lower_err())
            }
        }
    }

    fn not_expected<'tree>(&mut self, node: impl Node<'tree>) {
        self.diag_emitter
            .error(
                format!("{} not expected", node.kind()),
                self.current_origin.as_ref().unwrap().to_string(),
            )
            .err_at(node.byte_range(), "unexpected")
            .emit(self.source_text().expect("origin must be set to parse ast"));
    }

    fn not_implemented<'tree>(&mut self, node: impl Node<'tree>) {
        self.diag_emitter
            .error(
                format!("{} has not been implemented yet", node.kind()),
                self.current_origin.as_ref().unwrap().to_string(),
            )
            .err_at(node.byte_range(), "not implemented")
            .emit(self.source_text().expect("origin must be set to parse ast"));
    }

    fn lower_identifier<'tree, 'hir>(
        &mut self,
        node: nodes::Identifier<'tree>,
        arena: &'hir HirArena<'hir>,
    ) -> anyhow::Result<&'hir mut hir::Identifier<'hir>> {
        Ok(arena.alloc_identifier(hir::Identifier {
            source: self.node_source(node),
            text: self.node_text(node)?.to_string(),
            _lifetime: PhantomData::default(),
        }))
    }

    fn lower_pipeline<'tree, 'hir>(
        &mut self,
        node: nodes::Pipeline<'tree>,
        arena: &'hir HirArena<'hir>,
    ) -> anyhow::Result<&'hir mut hir::Pipeline<'hir>> {
        Err(anyhow!("not yet implemented"))
    }

    fn lower_module<'tree, 'hir>(
        &mut self,
        node: nodes::Module<'tree>,
        arena: &'hir HirArena<'hir>,
        modules: &mut HashMap<String, &'hir mut hir::Module<'hir>>,
    ) -> anyhow::Result<()> {
        let id_node = self.expect_node(node.id())?;
        let identifier: &mut hir::Identifier = self.lower_identifier(id_node, arena)?;

        let mut cursor = node.walk();
        if node.has_error() {
            cursor.goto_first_child();

            if cursor.node().is_error() {
                self.not_expected(cursor.node())
            }

            loop {
                if !cursor.goto_next_sibling() {
                    break;
                }
            }
        }

        let mut pipelines = HashMap::new();

        for def in node.defss(&mut cursor) {
            if let Ok(def) = self.expect_node(def) {
                match def {
                    nodes::anon_unions::Function_Module_Pipeline::Function(function) => {
                        self.not_implemented(function)
                    }
                    nodes::anon_unions::Function_Module_Pipeline::Module(module) => {
                        /*if let Ok(module) = self.lower_module(module, arena) {
                            modules.insert(module.identifier.text.clone(), module);
                        }*/
                    }
                    nodes::anon_unions::Function_Module_Pipeline::Pipeline(pipeline) => {
                        if let Ok(pipe) = self.lower_pipeline(pipeline, arena) {
                            pipelines.insert(pipe.identifier.text.clone(), pipe);
                        }
                    }
                }
            }
        }

        let mod_id = identifier.text.clone();
        let new_mod = arena.alloc_module(hir::Module {
            source: self.node_source(node),
            identifier,
            structs: HashMap::new(),
            functions: HashMap::new(),
            pipelines,
            links: Vec::new(),
        });
        modules.insert(mod_id, new_mod);
        Ok(())
    }

    fn lower_ast<'hir>(
        &mut self,
        ast: &Ast,
        modules: &mut HashMap<String, &'hir mut hir::Module<'hir>>,
        arena: &'hir HirArena<'hir>,
    ) -> anyhow::Result<()> {
        let root = self.expect_node(ast.tree().root_node())?;
        let mut cursor = root.walk();

        if root.has_error() {
            cursor.goto_first_child();
            cursor.goto_next_sibling();

            if cursor.node().is_error() {
                self.not_expected(cursor.node())
            }

            loop {
                if !cursor.goto_next_sibling() {
                    break;
                }
            }
        }

        for module in root.modules(&mut cursor) {
            let new_mod = self.expect_node(module);
            if let Ok(new_mod) = new_mod {
                let _ = self.lower_module(new_mod, arena, modules);
                //modules.insert(new_mod.identifier.text.clone(), new_mod);
            }
        }
        Ok(())
    }

    pub fn lower_asts<'hir, 'ast>(
        &mut self,
        asts: impl IntoIterator<Item = &'ast Ast>,
        arena: &'hir HirArena<'hir>,
    ) -> anyhow::Result<Hir<'hir>> {
        let mut modules = HashMap::new();
        for ast in asts.into_iter() {
            self.current_origin = Some(Arc::new(ast.source().clone()));
            let _ = self.lower_ast(ast, &mut modules, arena);
        }

        Ok(Hir { modules })
    }
}
