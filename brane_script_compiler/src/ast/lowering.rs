use super::nodes;
use anyhow::anyhow;
use std::{collections::HashMap, sync::Arc};
use type_sitter::Node;

use crate::{
    errors::DiagnosticEmitter,
    hir::{self, hir::Hir},
    source::{SourceManager, TextSource, Uri},
};

use super::ast::Ast;
use rodeo::bumpalo::Rodeo;

/// Lower ast generated by type_sitter down to hir

struct LoweringContext<'ctx, Emitter: DiagnosticEmitter> {
    diag_emitter: Arc<Emitter>,
    sources: &'ctx SourceManager,
    current_origin: Arc<Uri>,
}

fn lower_err() -> anyhow::Error {
    anyhow!("Failed to lower AST to HIR")
}

impl<'ctx, E: DiagnosticEmitter> LoweringContext<'ctx, E> {
    fn source_text(&self) -> anyhow::Result<&String> {
        self.sources.get(&self.current_origin)
    }

    fn node_source<'tree>(&self, node: impl Node<'tree>) -> TextSource {
        TextSource {
            source: self.current_origin.clone(),
            span: node.byte_range(),
        }
    }

    fn node_text<'tree>(&self, node: impl type_sitter::Node<'tree>) -> anyhow::Result<&str> {
        let range = node.byte_range();
        Ok(&self.source_text()?[range.start..range.end])
    }

    fn expect_node<'tree, T>(
        &self,
        result: type_sitter::NodeResult<'tree, T>,
    ) -> anyhow::Result<T> {
        match result {
            Ok(node) => Ok(node),
            Err(err) => {
                self.diag_emitter
                    .error(
                        format!(
                            "Was expecting {} but found \"{}\" with content: {}",
                            err.kind,
                            err.node.kind(),
                            self.node_text(err.node)?
                        ),
                        self.current_origin.to_string(),
                    )
                    .err_at(err.node.byte_range(), format!("expected {}", err.kind))
                    .emit(self.source_text()?);
                Err(lower_err())
            }
        }
    }

    fn not_implemented<'tree>(&mut self, node: impl Node<'tree>) {
        self.diag_emitter.error(
            format!("{} has not been implemented yet", node.kind()),
            self.current_origin.to_string(),
        );
    }

    fn alloc<'hir, T: 'static>(arena: &'hir mut Rodeo, value: T) -> &'hir mut T {
        unsafe { std::mem::transmute::<_, &'hir mut T>(arena.alloc(value)) }
    }

    fn lower_identifier<'tree, 'hir>(
        &mut self,
        node: nodes::Identifier<'tree>,
        arena: &'hir Rodeo,
    ) -> anyhow::Result<&'hir mut hir::Identifier> {
        Ok(arena.alloc(hir::Identifier {
            source: self.node_source(node),
            text: self.node_text(node)?.to_string(),
        }))
    }

    fn lower_pipeline<'tree, 'hir>(
        &mut self,
        node: nodes::Pipeline<'tree>,
        arena: &'hir mut Rodeo,
    ) -> anyhow::Result<&'hir mut hir::Pipeline<'hir>> {
        Err(anyhow!("not yet implemented"))
    }

    fn lower_module<'tree, 'hir>(
        &mut self,
        node: nodes::Module<'tree>,
        arena: &'hir mut Rodeo,
    ) -> anyhow::Result<&'hir mut hir::Module<'hir>> {
        let identifier: &'hir mut hir::Identifier =
            self.lower_identifier(self.expect_node(node.id())?, arena)?;

        let mut cursor = node.walk();

        let mut pipelines = HashMap::new();
        let mut modules = HashMap::new();

        for def in node.defss(&mut cursor) {
            if let Ok(def) = self.expect_node(def) {
                match def {
                    nodes::anon_unions::Function_Module_Pipeline::Function(function) => {
                        self.not_implemented(function)
                    }
                    nodes::anon_unions::Function_Module_Pipeline::Module(module) => {
                        if let Ok(module) = self.lower_module(module, arena) {
                            modules.insert(module.identifier.text.clone(), module);
                        }
                    }
                    nodes::anon_unions::Function_Module_Pipeline::Pipeline(pipeline) => {
                        if let Ok(pipe) = self.lower_pipeline(pipeline, arena) {
                            pipelines.insert(pipe.identifier.text.clone(), pipe);
                        }
                    }
                }
            }
        }

        Ok(Self::alloc::<hir::Module<'hir>>(
            arena,
            hir::Module {
                source: self.node_source(node),
                identifier,
                structs: HashMap::new(),
                functions: HashMap::new(),
                pipelines,
                links: Vec::new(),
            },
        ))
    }

    fn lower_ast<'hir>(
        &mut self,
        ast: &Ast,
        modules: &mut HashMap<String, &'hir mut hir::Module<'hir>>,
        arena: &'hir mut Rodeo,
    ) -> anyhow::Result<()> {
        let root = self.expect_node(ast.tree().root_node())?;
        let mut cursor = root.walk();
        for module in root.modules(&mut cursor) {
            if let Ok(new_mod) = self
                .expect_node(module)
                .and_then(|module| self.lower_module(module, arena))
            {
                modules.insert(new_mod.identifier.text.clone(), new_mod);
            }
        }
        Ok(())
    }

    pub fn lower_asts<'hir>(&mut self, asts: &[&Ast]) -> anyhow::Result<Hir> {
        Hir::build(|arena: &Rodeo| {
            let mut modules = HashMap::new();
            for ast in asts {
                self.current_origin = Arc::new(ast.source().clone());
                let _ = self.lower_ast(ast, &mut modules, arena);
            }

            Ok(modules)
        })
    }
}
