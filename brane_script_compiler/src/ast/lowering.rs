use anyhow::anyhow;
use scopeguard::ScopeGuard;
use std::{collections::HashMap, sync::Arc};

use crate::{
    ast::ast,
    errors::DiagnosticEmitter,
    hir::{self, hir::Hir},
    source::Uri,
};

/// Lower ast generated by type_sitter down to hir
pub struct LoweringContext<'hir, Emitter: DiagnosticEmitter> {
    pub emitter: Arc<Emitter>,
    pub origin: Arc<Uri>,
    pub modules: HashMap<String, &'hir mut hir::Module>,
    pub current_path: Option<&'hir hir::Path>,
}

enum ErrorKind {}

type Error<T> = Result<T, ErrorKind>;

fn lower_err() -> anyhow::Error {
    anyhow!("Failed to lower AST to HIR")
}

impl<'hir, Emitter: DiagnosticEmitter> LoweringContext<'hir, Emitter> {
    fn push_path(
        &mut self,
        segment: &'hir hir::PathSegment,
    ) -> ScopeGuard<Option<&'hir hir::Path>, impl FnOnce(Option<&'hir hir::Path>) + '_> {
        let span = segment.ident.span.clone();
        let old_path = match self.current_path.take() {
            Some(path) => {
                let mut segments = path.segments.clone();
                segments.push(segment);
                self.current_path = Some(self.arena.alloc_path(hir::Path { span, segments }));
                Some(path)
            }
            None => {
                self.current_path = Some(self.arena.alloc_path(hir::Path {
                    span,
                    segments: vec![segment],
                }));
                None
            }
        };
        scopeguard::guard(old_path, |old_path| {
            self.current_path = old_path;
        })
    }

    fn lower_ident(&mut self, node: &ast::Ident) -> &'hir mut hir::Ident {
        self.arena.alloc_ident(hir::Ident {
            span: node.span.clone(),
            id: todo!(),
        })
    }

    fn lower_pipeline(&mut self, node: &ast::Pipe) -> anyhow::Result<&'hir mut hir::Pipeline> {
        Err(anyhow!("not yet implemented"))
    }

    fn lower_module(&mut self, node: &ast::Mod) -> anyhow::Result<()> {
        let ident = self.lower_ident(&node.ident);

        let path_segment = self.arena.alloc_pathsegment(hir::PathSegment {
            ident,
            args: None,
            infer_args: false,
        });

        self.push_path(path_segment);

        for item in node.items.iter() {
            use ast::Item::*;
            match item {
                Pipe(pipe) => {
                    //let new_pipe = self.lower_pipeline(pipe.as_ref())?;
                    //pipelines.insert(new_pipe.ident.text.clone(), new_pipe);
                }
                Mod(module) => self.lower_module(module.as_ref())?,
            }
        }

        let new_mod = self.arena.alloc_module(hir::Module {
            structs: HashMap::new(),
            functions: HashMap::new(),
            pipelines,
            links: Vec::new(),
            span: node.span.clone(),
            ident,
        });
        let path = self
            .current_path
            .as_ref()
            .expect("should be in our own scope");
        self.modules.insert(path.to_string(), new_mod);
        Ok(())
    }

    fn lower_ast(&mut self, ast: &ast::Ast) -> anyhow::Result<()> {
        for module in ast.modules.iter() {
            self.lower_module(module)?;
        }
        Ok(())
    }

    pub fn lower(ast: &ast::Ast, emitter: Arc<Emitter>) -> anyhow::Result<Hir> {
        let modules = HashMap::new();

        let mut ctx = Self {
            emitter,
            modules,
            origin: ast.span.source.clone(),
            current_path: None,
        };

        ctx.lower_ast(ast)?;

        Ok(Hir {
            modules: ctx.modules,
        })
    }
}
