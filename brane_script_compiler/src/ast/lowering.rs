use anyhow::anyhow;
use std::{collections::HashMap, marker::PhantomData, sync::Arc};

use crate::{
    errors::DiagnosticEmitter,
    hir::{
        self,
        hir::{Hir, HirArena},
        HirKind,
    },
    source::{SourceManager, Span, Uri},
};

use super::ast::Ast;

/// Lower ast generated by type_sitter down to hir

pub struct LoweringContext<'ctx, Emitter: DiagnosticEmitter> {
    pub diag_emitter: Arc<Emitter>,
    pub origin: Arc<Uri>,
}

enum ErrorKind<'ast, 'src> {}

type Error<'ast, 'src, T> = Result<T, ErrorKind<'ast, 'src>>;

fn lower_err() -> anyhow::Error {
    anyhow!("Failed to lower AST to HIR")
}

impl<'ctx, E: DiagnosticEmitter> LoweringContext<'ctx, E> {
    fn lower_identifier<'tree, 'hir>(
        &mut self,
        node: nodes::Identifier<'tree>,
        arena: &'hir HirArena<'hir>,
    ) -> anyhow::Result<&'hir mut hir::Identifier<'hir>> {
        Ok(arena.alloc_identifier(hir::Identifier {
            source: self.node_source(node),
            text: self.node_text(node)?.to_string(),
            _lifetime: PhantomData::default(),
        }))
    }

    fn lower_pipeline<'tree, 'hir>(
        &mut self,
        node: nodes::Pipeline<'tree>,
        arena: &'hir HirArena<'hir>,
    ) -> anyhow::Result<&'hir mut hir::Pipeline<'hir>> {
        Err(anyhow!("not yet implemented"))
    }

    fn lower_module<'tree, 'hir>(
        &mut self,
        node: nodes::Module<'tree>,
        arena: &'hir HirArena<'hir>,
        modules: &mut HashMap<String, &'hir mut hir::Module<'hir>>,
    ) -> anyhow::Result<()> {
        let id_node = self.expect_node(node.id())?;
        let identifier: &mut hir::Identifier = self.lower_identifier(id_node, arena)?;

        let mut cursor = node.walk();
        if node.has_error() {
            cursor.goto_first_child();

            if cursor.node().is_error() {
                self.not_expected(cursor.node())
            }

            loop {
                if !cursor.goto_next_sibling() {
                    break;
                }
            }
        }

        let mut pipelines = HashMap::new();

        for def in node.defss(&mut cursor) {
            if let Ok(def) = self.expect_node(def) {
                match def {
                    nodes::anon_unions::Function_Module_Pipeline::Function(function) => {
                        self.not_implemented(function)
                    }
                    nodes::anon_unions::Function_Module_Pipeline::Module(module) => {
                        /*if let Ok(module) = self.lower_module(module, arena) {
                            modules.insert(module.identifier.text.clone(), module);
                        }*/
                    }
                    nodes::anon_unions::Function_Module_Pipeline::Pipeline(pipeline) => {
                        if let Ok(pipe) = self.lower_pipeline(pipeline, arena) {
                            pipelines.insert(pipe.identifier.text.clone(), pipe);
                        }
                    }
                }
            }
        }

        let mod_id = identifier.text.clone();
        let new_mod = arena.alloc_module(hir::Module {
            source: self.node_source(node),
            identifier,
            structs: HashMap::new(),
            functions: HashMap::new(),
            pipelines,
            links: Vec::new(),
        });
        modules.insert(mod_id, new_mod);
        Ok(())
    }

    fn lower_ast<'hir>(
        &mut self,
        ast: &Ast,
        modules: &mut HashMap<String, &'hir mut hir::Module<'hir>>,
        arena: &'hir HirArena<'hir>,
    ) -> anyhow::Result<()> {
        let mut cursor = root.walk();

        if root.has_error() {
            cursor.goto_first_child();
            cursor.goto_next_sibling();

            if cursor.node().is_error() {
                self.not_expected(cursor.node())
            }

            loop {
                if !cursor.goto_next_sibling() {
                    break;
                }
            }
        }

        for module in root.modules(&mut cursor) {
            let new_mod = self.expect_node(module);
            if let Ok(new_mod) = new_mod {
                let _ = self.lower_module(new_mod, arena, modules);
                //modules.insert(new_mod.identifier.text.clone(), new_mod);
            }
        }
        Ok(())
    }

    pub fn lower_ast<'hir, 'ast>(
        &mut self,
        ast: &'ast Ast<'ast>,
        arena: &'hir HirArena<'hir>,
    ) -> anyhow::Result<Hir<'hir>> {
        let mut modules = HashMap::new();

        self.current_origin = Some(Arc::new(ast.source().clone()));

        let _ = self.lower_ast(ast, &mut modules, arena);

        Ok(Hir { modules })
    }
}
