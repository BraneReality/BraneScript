// ABI Compliance Tests for C FFI compatibility
// Testing struct and enum passing conventions across different sizes

// === STRUCT SIZE TESTS ===

// Struct < 64 bits (4 bytes) - typically passed in registers
struct Struct4B {
    field: i32,
}

fn abi_test_struct_4b(input: Struct4B) -> Struct4B {
    return input;
}

// Struct = 64 bits (8 bytes) - typically passed in one register
struct Struct8B {
    field: i64,
}

fn abi_test_struct_8b(input: Struct8B) -> Struct8B {
    return input;
}

// Struct = 128 bits (16 bytes) - typically passed in two registers
struct Struct16B {
    field1: i64,
    field2: i64,
}

// Struct = 128 bits (16 bytes) - typically passed in two registers, on some archetectures in vector registers
struct Struct16BF {
    field1: f32,
    field2: f32,
    field3: f32,
    field4: f32,
}

fn abi_test_struct_16b(input: Struct16B) -> Struct16B {
    return input;
}

// Struct > 128 bits (24 bytes) - typically passed by pointer
struct Struct24B {
    field1: i64,
    field2: i64,
    field3: i64,
}

fn abi_test_struct_24b(input: Struct24B) -> Struct24B {
    return input;
}

fn abi_test_struct_16f(input: Struct16BF) -> Struct16BF{
    return input;
}

// === EMPTY ENUM TESTS ===

// Empty enum with 2 variants - u8 discriminant
enum EnumEmpty2 {
    Variant1,
    Variant2,
}

fn abi_test_enum_empty_2(input: EnumEmpty2) -> EnumEmpty2 {
    return input;
}

// Empty enum with 256 variants - u8 discriminant at limit
enum EnumEmpty256 {
    V1, V2, V3, V4, V5, V6, V7, V8, V9, V10,
    V11, V12, V13, V14, V15, V16, V17, V18, V19, V20,
    V21, V22, V23, V24, V25, V26, V27, V28, V29, V30,
    V31, V32, V33, V34, V35, V36, V37, V38, V39, V40,
    V41, V42, V43, V44, V45, V46, V47, V48, V49, V50,
    V51, V52, V53, V54, V55, V56, V57, V58, V59, V60,
    V61, V62, V63, V64, V65, V66, V67, V68, V69, V70,
    V71, V72, V73, V74, V75, V76, V77, V78, V79, V80,
    V81, V82, V83, V84, V85, V86, V87, V88, V89, V90,
    V91, V92, V93, V94, V95, V96, V97, V98, V99, V100,
    V101, V102, V103, V104, V105, V106, V107, V108, V109, V110,
    V111, V112, V113, V114, V115, V116, V117, V118, V119, V120,
    V121, V122, V123, V124, V125, V126, V127, V128, V129, V130,
    V131, V132, V133, V134, V135, V136, V137, V138, V139, V140,
    V141, V142, V143, V144, V145, V146, V147, V148, V149, V150,
    V151, V152, V153, V154, V155, V156, V157, V158, V159, V160,
    V161, V162, V163, V164, V165, V166, V167, V168, V169, V170,
    V171, V172, V173, V174, V175, V176, V177, V178, V179, V180,
    V181, V182, V183, V184, V185, V186, V187, V188, V189, V190,
    V191, V192, V193, V194, V195, V196, V197, V198, V199, V200,
    V201, V202, V203, V204, V205, V206, V207, V208, V209, V210,
    V211, V212, V213, V214, V215, V216, V217, V218, V219, V220,
    V221, V222, V223, V224, V225, V226, V227, V228, V229, V230,
    V231, V232, V233, V234, V235, V236, V237, V238, V239, V240,
    V241, V242, V243, V244, V245, V246, V247, V248, V249, V250,
    V251, V252, V253, V254, V255, V256,
}

fn abi_test_enum_empty_256(input: EnumEmpty256) -> EnumEmpty256 {
    return input;
}

// === SINGLE VARIANT ENUM TESTS ===

// Enum with single 4B variant - discriminant + 4B payload
enum EnumSingle4B {
    Variant(Struct4B),
}

fn abi_test_enum_single_4b(input: EnumSingle4B) -> EnumSingle4B {
    return input;
}

// Enum with single 8B variant - discriminant + 8B payload
enum EnumSingle8B {
    Variant(Struct8B),
}

fn abi_test_enum_single_8b(input: EnumSingle8B) -> EnumSingle8B {
    return input;
}

// Enum with single 16B variant - discriminant + 16B payload
enum EnumSingle16B {
    Variant(Struct16B),
}

fn abi_test_enum_single_16b(input: EnumSingle16B) -> EnumSingle16B {
    return input;
}

// Enum with single 24B variant - discriminant + 24B payload
enum EnumSingle24B {
    Variant(Struct24B),
}

fn abi_test_enum_single_24b(input: EnumSingle24B) -> EnumSingle24B {
    return input;
}

// === MULTI VARIANT SAME SIZE ENUM TESTS ===

// Enum with multiple 4B variants
enum EnumMulti4B {
    Variant1(Struct4B),
    Variant2(Struct4B),
}

fn abi_test_enum_multi_4b(input: EnumMulti4B) -> EnumMulti4B {
    return input;
}

// Enum with multiple 8B variants
enum EnumMulti8B {
    Variant1(Struct8B),
    Variant2(Struct8B),
}

fn abi_test_enum_multi_8b(input: EnumMulti8B) -> EnumMulti8B {
    return input;
}

// Enum with multiple 16B variants
enum EnumMulti16B {
    Variant1(Struct16B),
    Variant2(Struct16B),
}

fn abi_test_enum_multi_16b(input: EnumMulti16B) -> EnumMulti16B {
    return input;
}

// Enum with multiple 24B variants
enum EnumMulti24B {
    Variant1(Struct24B),
    Variant2(Struct24B),
}

fn abi_test_enum_multi_24b(input: EnumMulti24B) -> EnumMulti24B {
    return input;
}

// === MIXED SIZE ENUM TESTS ===

// Enum with mixed sizes: 4B and 8B variants
enum EnumMixed4B8B {
    Variant4B(Struct4B),
    Variant8B(Struct8B),
}

fn abi_test_enum_mixed_4b_8b(input: EnumMixed4B8B) -> EnumMixed4B8B {
    return input;
}

// Enum with mixed sizes: 4B, 8B, and 16B variants
enum EnumMixed4B8B16B {
    Variant4B(Struct4B),
    Variant8B(Struct8B),
    Variant16B(Struct16B),
}

fn abi_test_enum_mixed_4b_8b_16b(input: EnumMixed4B8B16B) -> EnumMixed4B8B16B {
    return input;
}

// Enum with all sizes: 4B, 8B, 16B, and 24B variants
enum EnumMixedAll {
    Variant4B(Struct4B),
    Variant8B(Struct8B),
    Variant16B(Struct16B),
    Variant24B(Struct24B),
}

fn abi_test_enum_mixed_all(input: EnumMixedAll) -> EnumMixedAll {
    return input;
}

// === COMBINED PARAMETER TESTS ===

// Multiple struct parameters of different sizes
fn abi_test_multi_params(s4: Struct4B, s8: Struct8B, s16: Struct16B, s24: Struct24B) -> Struct24B {
    return s24;
}

// On SystemV x86_64 structs can take up to registers, but should be passed on the stack
// if they can't completely be passed in registers. 
fn abi_test_exaust_general(p1: i32, p2: f32, p3: i32, p3: i32, value: Struct16B) -> Struct16B {
    return value;
}

fn abi_test_exaust_vector(p1: f32, p2: i32, p3: f32, p3: f32, value: Struct16BF) -> Struct16BF {
    return value;
}
